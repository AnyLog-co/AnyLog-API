import argparse
import os
import sys
ROOT_PATH = os.path.dirname(os.path.abspath(__file__)).split('configs')[0]
REST_PATH = os.path.join(ROOT_PATH, 'REST')
sys.path.insert(0, REST_PATH)

from anylog_connection import AnyLogConnection
import configs_support
import generic_get_calls
import generic_post_calls
import database_calls


PARAMS = {
    "anylog_general": {
        "hostname": "get hostname",
        "company_name": "Company Name",
        "node_name": "new-node",
        "node_type": "operator" # master, operator, publisher, query, standalone (master+operator), standalone-publisher (master+publisher)
    },
    "anylog_network": {
        # A user should only change the external and (local) IPs if they don't want to use the defaults.
        "external_ip": "",
        "ip": "",
        "anylog_server_port": 2148,
        "anylog_rest_port": 2149
    },
    "anylog_database": {
        "db_type": "psql", # if db_type == sqlite then all other db params are not needed
        "db_ip": "127.0.0.1",
        "db_port": 5432,
        "db_user": "admin",
        "db_passwd": "passwd"
    },
    "anylog_blockchain": {
        "master_node": "127.0.0.1:2048",
        "source": "master",
        "sync_time": "30 seconds",
        "dest": "dbms"
    },
    "anylog_operator": { # operator specific params
        "default_dbms": "aiops",
        "enable_partitions": "true",
        "cluster_name": "aiops-cluster1",
        "table_name": "*",
        "partition_column": "timestamp",
        "partition_interval": "14 days",
        "partition_keep":  6, # keep about 3 months of data
        "partition_sync": "1 day"
    },
    "anylog_mqtt": { # mqtt params, not needed if deployment of type not master or query
        "enable_mqtt": True,
        "broker": "rest",
        "mqtt_port": 32149,
        "mqtt_log ": "false",
        "mqtt_topic_name": "aiops",
        "mqtt_topic_dbms": "bring [dbms]", # alternatively you can set the default to be [anylog_operator][default_dbms]
        "mqtt_topic_table": "bring [table]",
        "mqtt_column_timestamp": "bring [ts]",
        "mqtt_column_value": "bring [value]",
        "mqtt_column_value_type": "float"
    },
    "anylog_deployment": { # deployment params, not needed if deployment of type not master or query
        # file name format: [db_name].[table_name].[autogenerated_file_id].json
        "dbms_name": "bring file_name[0]", # alternatively you can set the default to be [anylog_operator][default_dbms]
        "table_name": "bring file_name[1]",

        # run operator Params (needed for node_type == operator)
        "create_table": True,
        "update_tsd_info": True,
        "archive": True,
        "distributor": True,

        # run publisher params (needed for node_type == publisher)
        "compress_json": True,
        "move_json": True,
    }
}


def main():
    """
    The following stores the configuration parameters into logical database tables and then converts then
    into the AnyLog dictionary.
    :note:
        for db_type of type SQLite there's no need to specify (other) database params
    :positional arguments:
        conn                        REST IP/Port connection to work against
        db_type     {psql,sqlite}   database type
    :optional arguments:
        -h, --help                      show this help message and exit
        --db-ip         DB_IP           database IP
        --db-port       DB_PORT         database port
        --db-user       DB_USER         database user
        --db-passwd     DB_PASSWD       password correlated to database user
        --auth          AUTH            Authentication (user, passwd) for node
        --timeout       TIMEOUT         REST timeout
        --exception     [EXCEPTION]     whether to print exception
    :params:
        global DEFAULT_PARAMS:list - list of key params that the default should be saved
        db_name:str - logical database name
        table_name:str - database table to store data into
        anylog_conn:anylog_conn:anylog_connection.AnyLogConnection - Connection to AnyLog via REST
        dictionary_values:dict - AnyLog's dictionary values
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('conn',         type=str,   default='127.0.0.1:2049', help='REST IP/Port connection to work against')
    parser.add_argument('db_type',      type=str,   default='sqlite',         choices=['psql', 'sqlite'], help='database type')
    parser.add_argument('--db-ip',      type=str,   default='127.0.0.1',      help='database IP')
    parser.add_argument('--db-port',    type=int,   default=5432,             help='database port')
    parser.add_argument('--db-user',    type=str,   default='admin',          help='database user')
    parser.add_argument('--db-passwd',  type=str,   default='passwd',         help='password correlated to database user')
    parser.add_argument('--auth',       type=tuple, default=(), help='Authentication (user, passwd) for node')
    parser.add_argument('--timeout',    type=int,   default=30, help='REST timeout')
    parser.add_argument('--exception',  type=bool,  nargs='?',  const=True, default=False, help='whether to print exception')
    args = parser.parse_args()

    db_name = 'configs'

    anylog_conn = AnyLogConnection(conn=args.conn, auth=args.auth, timeout=args.timeout)
    if not generic_get_calls.validate_status(anylog_conn=anylog_conn, exception=args.exception):
        print(f'Failed to validate connection to AnyLog on {anylog_conn.conn}')
        exit(1)

    database_calls.connect_dbms(anylog_conn=anylog_conn, db_name=db_name, db_type=args.db_type, db_ip=args.db_ip,
                                db_port=args.db_port, db_user=args.db_user, db_passwd=args.db_passwd,
                                exception=args.exception)

    for table_name in list(PARAMS.keys()):
        configs_support.create_table(anylog_conn=anylog_conn, db_type=args.db_type, table_name=table_name,
                                     db_name=db_name, exception=args.exception)
        for param in PARAMS[table_name]:
            configs_support.insert_data(anylog_conn=anylog_conn, table_name=table_name,
                                        insert_data={param: PARAMS[table_name][param]}, db_name=db_name,
                                        exception=args.exception)
        generic_post_calls.convert_db_to_dict(anylog_conn=anylog_conn, db_name=db_name, table_name=table_name,
                                              condition=None, exception=args.exception)


if __name__ == '__main__':
    main()